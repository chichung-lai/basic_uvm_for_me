31,40d30
< //class my_transaction_da3 extends my_transaction;
< //
< //    `uvm_object_utils(my_transaction_da3)
< //
< //    constraint limit {da  == 3;}
< //    function new(string name = "my_transaction_da3");
< //        super.new(name);
< //    endfunction
< //
< //endclass
41a32,41
> class my_transaction_da3 extends my_transaction;
> 
>     `uvm_object_utils(my_transaction_da3)
> 
>     constraint da3{da == 3;}
>     function new(string name = "my_transaction_da3");
>         super.new(name);
>     endfunction
> 
> endclass
50c50
<     
---
> 
91c91,92
<     virtual dut_interface m_vif;   //imp DUT  new
---
>     virtual dut_interface m_vif;
>     int unsigned pad_cycles;
97c98
<     virtual function void build_phase(uvm_phase phase);        //new
---
>     virtual function void build_phase(uvm_phase phase);
99c100,107
< 	uvm_config_db#(virtual dut_interface)::get(this,"","vif",m_vif);   //connect DUT
---
>         if(!uvm_config_db#(int unsigned)::get(this, "", "pad_cycles", pad_cycles)) begin
>             `uvm_fatal("CONFIG_FATAL", "Driver can not get the pad_cycles !!!")
>         end
>         $diplay("pad cycles = %0d", pad_cycles);
>         if(!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", m_vif)) begin
>             `uvm_fatal("CONFIG_FATAL", "Driver can not get the interface !!!")
>         end
>         uvm_config_db#(virtual dut_interface)::get(this, "", "vif", m_vif);
101,102c109,110
<     
<     virtual task pre_reset_phase(uvm_phase phase);//new
---
> 
>     vittual function pre_reset_phase(uvm_phase phase);
104,113c112,121
< 	`uvm_info("TRACE",$sformatf("%m"),UVM_HIGH)
< 	phase.raise_objection(this);
< 	m_vif.driver_cb.frame_n <= 'x;
< 	m_vif.driver_cb.valid_n <= 'x;
< 	m_vif.driver_cb.din     <= 'x;
< 	m_vif.driver_cb.reset_n <= 'x;
< 	phase.drop_objection(this);
<     endtask
<     
<     virtual task reset_phase(uvm_phase phase);//new
---
>         `uvm_info("TRACE", $sformatf("%m"), UVM_HIGH)
>         phase.raise_objection(this);
>             m_vif.driver_cb.frame_n <= 'x;
>             m_vif.driver_cb.valid_n <= 'x;
>             m_vif.driver_cb.din <= 'x;
>             m_vif.driver_cb.reset_n <= 'x;
>         phase.drop_objection(this);
>     endfunction
> 
>     virtual task reset_phase(uvm_phase phase);
115,125c123,133
< 	`uvm_info("TRACE",$sformatf("%m"),UVM_HIGH)
< 	phase.raise_objection(this);
< 	m_vif.driver_cb.frame_n <= '1;
< 	m_vif.driver_cb.valid_n <= '1;
< 	m_vif.driver_cb.din     <= '0;
< 	m_vif.driver_cb.reset_n <= '1;
< 	repeat(5)@(m_vif.driver_cb);
< 	m_vif.driver_cb.reset_n <= '0;
< 	repeat(5)@(m_vif.driver_cb);
< 	m_vif.driver_cb.reset_n <= '1;
< 	phase.drop_objection(this);
---
>         `uvm_info("TRACE", $sformatf("%m"), UVM_HIGH)
>         phase.raise_objection(this);
>             m_vif.driver_cb.frame_n <= '1;
>             m_vif.driver_cb.valid_n <= '1;
>             m_vif.driver_cb.din <= '0;
>             m_vif.driver_cb.reset_n <= '1;
>             repeat(5) @(m_vif.driver_cb);
>                 m_vif.driver_cb.reset_n <= '0;
>             repeat(5) @(m_vif.driver_cb);
>                 m_vif.driver_cb.reset_n <= '1;
>         phase.drop_objection(this);
127a136,143
>     virtual task configure_phase(uvm_phase phase);
>         phase.raise_objection(this);
>         #100;
>         `uvm_info("DRV_CONFIGURE_PHASE", "Now driver config the DUT...", UVM_MEDIUM)
>         phase.drop_objection(this);
>     endtask
> 
> 
130c146
< 	repeat(15)@(m_vif.driver_cb);
---
>         repeat(15)@(m_vif.driver_cb);
134,154c150,173
< 	    //send address
< 	    m_vif.driver_cb.frame_n[req.sa] <= 1'b0;
< 	    for(int i=0; i<4; i++)begin
<                m_vif.driver_cb.din[req.sa] <= req.da[i];
< 	       @(m_vif.driver_cb);
< 	    end
< 	    //send pad
< 	    m_vif.driver_cb.din[req.sa] <= 1'b1;
< 	    m_vif.driver_cb.valid_n[req.sa] <= 1'b1;
< 	    repeat(5)@(m_vif.driver_cb);
< 	    //send payload
< 	    while(!m_vif.driver_cb.busy_n[req.sa])@(m_vif.driver_cb);
< 	    foreach(req.payload[index])begin
< 	      temp = req.payload[index];
< 	      for(int i=0; i<8; i++)begin
< 		m_vif.driver_cb.din[req.sa]     <= temp[i];
< 		m_vif.driver_cb.valid_n[req.sa] <= 1'b0;
< 		m_vif.driver_cb.frame_n[req.sa] <= ((req.payload.size()-1) == index) && (i==7);
< 		@(m_vif.driver_cb);
< 	      end
< 	    end
---
>             
>             // Send address
>             m_vif.driver_cb.frame_n[req.sa] <= 1'b0;
>             for(int i=0; i<4; i++) begin
>                 m_vif.driver_cb.din[req.sa] <= req.da[i];
>                 @(m_vif.driver_cb);
>             end
> 
>             //Send pad
>             m_vif.driver_cb.din[req.sa] <= 1'b1;
>             m_vif.driver_cb.valid_n[req.sa] <= 1'b1;
>             repeat(pad_cycles) @(m_vif.driver_cb);
> 
>             //Send payload
>             while(!m_vif.driver_cb.busy_n[req.sa]) @(m_vif.driver_cb);
>             foreach(req.payoad[index]) begin
>                 temp = req.payload[index];
>                 for(int i=0; i<8; i++) begin
>                     m_vif.driver_cb.din[req.sa] <= temp[i];
>                     m_vif.driver_cb.valid_n[req.sa] <= 1'b0;
>                     m_vif.driver_cb.frame_n[req.sa] <= ((req.payload.size()-1)==index) && (i==7);
>                     @(m_vif.driver_cb);
>                 end
>             end
156c175,176
<             seq_item_port.item_done();         
---
> 
>             seq_item_port.item_done();        
158a179
> 
173,177c194,198
<      
< //    virtual task reset_phase(uvm_phase phase);
< //      #50
< //      `uvm_info("MON_RESET_PHASE","NOW Monitor reset_phase running !",UVM_MEDIUM)
< //    endtask
---
>     
>     virtual task reset_phase(uvm_phase phase);
>         #150;
>         `uvm_info("MON_RESET_PHASE", "Now Monitor reset phase running !", UVM_MEDIUM)
>     endtask
178a200
>     
198c220,221
<     bit if_active = 1;    
---
>     bit is_active = 1;
>     agent_config m_agent_cfg;    
206,249d228
<         if(is_active == UVM_ACTIVE) begin
<             m_seqr = my_sequencer::type_id::create("m_seqr", this);
<             m_driv = my_driver::type_id::create("m_driv", this);
<         end
<         m_moni = my_monitor::type_id::create("m_moni", this);
<     endfunction
< 
<     virtual function void connect_phase(uvm_phase phase);
<         if (is_active == UVM_ACTIVE)
<             m_driv.seq_item_port.connect(m_seqr.seq_item_export);
<     endfunction
< 
< 
< endclass
< 
< 
< 
< 
< //env
< 
< class my_env extends uvm_env;
< 
<     `uvm_component_utils(my_env)
< 
<     master_agent m_agent;
< 
<     function new(string name="", uvm_component parent);
<         super.new(name, parent);
<     endfunction
< 
<     virtual function void build_phase(uvm_phase phase);
<     
< 
< 
<     virtual task run_phase(uvm_phase phase);
<         forever begin
<             seq_item_port.get_next_item(req);
<             `uvm_info("DRV_RUN_PHASE", req.sprint(), UVM_MEDIUM) //print
<             #100;
<             seq_item_port.item_done();        
<         end
<     endtask
< 
< endclass
251,272c230,231
< 
< 
< 
< //monitor
< 
< class my_monitor extends uvm_monitor;
< 
<     `uvm_component_utils(my_monitor)
< 
<     function new(string name ="", uvm_component parent);
<         super.new(name, parent);
<     endfunction
<      
< //    virtual task reset_phase(uvm_phase phase);
< //      #50
< //      `uvm_info("MON_RESET_PHASE","NOW Monitor reset_phase running !",UVM_MEDIUM)
< //    endtask
< 
<     virtual task run_phase(uvm_phase phase);
<         forever begin
<             `uvm_info("MON_RUN_PHASE", "Monitor run!", UVM_MEDIUM)
<             #100;
---
>         if (! uvm_config_db#(agent_config)::get(this, "", "m_agent_cfg", m_agent_cfg))begin
>             `uvm_fatal("CONFIG_FATAL", "master_agent can not get the configuration !!!")
274,275d232
<     endtask
< endclass  
276a234
>         is_active = m_agent_cfg.is_active;
277a236,237
>         uvm_config_db#(int unsigned)::set(this, "m_driv", "pad_cycles", m_agent_cfg.pad_cycles);
>         uvm_config_db#(virtual dut_interface)::set(this, "m_driv", "vif", m_agent_cfg.vif);
279,295d238
< //agent
< 
< class master_agent extends uvm_agent;
< 
<     `uvm_component_utils(master_agent)
< 
<     my_sequencer m_seqr;
<     my_driver m_driv;
<     my_monitor m_moni;
<     bit if_active = 1;    
< 
<     function new(string name="", uvm_component parent);
<         super.new(name, parent);
<     endfunction
< 
<     virtual function void build_phase(uvm_phase phase);
<         super.build_phase(phase);
320a264
>     env_config m_env_cfg;
330a275,288
>         if (! uvm_config_db#(env_config)::get(this, "", "env_cfg", m_env_cfg))begin
>             `uvm_fatal("CONFIG_FATAL", "ENV can not get the configuration !!!")
>         end
> 
>         uvm_config_db#(agent_config)::set(this, "m_agent", "m_agent_cfg", m_env_cfg.m_agent_cfg);
> 
>         if(m_enc_cfg.is_coverage) begin
>             `uvm_info("COVERAGE_ENABLE", "The function coverage is enabled for this testcase", UVM_MEDIUM)
>         end
> 
>         if(m_enc_cfg.is_check) begin
>             `uvm_info("CHECK_ENABLE", "The check function is enabled for this testcase", UVM_MEDIUM)
>         end
> 
338a297
> 
345a305
>     env_config m_env_cfg;
348a309
>         m_env_cfg = new("m_env_cfg");
356,385c317
<         uvm_config_db # (int)::set(this,"*.m_seqr","item_num",20);
<     endfunction
< 
<     virtual function void start_of_simulation_phase(uvm_phase phase);
<         super.start_of_simulation_phase(phase);
<         uvm_top.print_topology(uvm_default_tree_printer); //print
<     endfunction
< 
< endclass
< 
< //class my_test_type_da3 extends my_test;
< //
< //    `uvm_component_utils(my_test_type_da3)
< //
< //    function new(string name="", uvm_component parent);
< //        super.new(name, parent);
< //    endfunction
< //   
< //    virtual function void build_phase(uvm_phase phase);
< //        super.build_phase(phase);
< //        set_type_override_by_type(my_transaction::get_type(), 
< //                                  my_transaction_da3::get_type()); 
< //    endfunction 
< //
< //
< //    virtual function void report_phase(uvm_phase phase);
< //        super.report_phase(phase);
< //        factory.print();
< //    endfunction
< //endclass
---
>         uvm_config_db#(int)::set(this, "*.m_seqr", "item_num", 3);
386a319,322
>         m_env_cfg.is_coverage = 1;
>         m_env_cfg.is_check = 1;
>         m_env_cfg.m_ganet_cfg.is_active = UVM_ACTIVE;
>         m_env_cfg.m_ganet_cfg.pad_cycles = 10;
387a324,325
>         if(!uvm_config_db#(virtual dut_interface)::get(
>             tihs, "". "top_if", m_env_cfg.m_ganet_cfg.m_vif))begin
388a327,328
>             `uvm_fatal("CONFIG_ERROR", "test can not get the interface!!!")
>         end
390,394c330
< //********************************************************************
< // New Da3 override
< //********************************************************************
< 
< class my_transaction_da3 extends my_transaction;
---
>         uvm_config_db#(env_config)::get(this, "m_env", "enc_cfg", m_env_cfg); 
396c332
<     `uvm_object_utils(my_transaction_da3)
---
>     endfunction
398,400c334,336
<     constraint da3{da == 3;}
<     function new(string name = "my_transaction_da3");
<         super.new(name);
---
>     virtual function void start_of_simulation_phase(uvm_phase phase);
>         super.start_of_simulation_phase(phase);
>         uvm_top.print_topology(uvm_default_tree_printer); //print
404a341
> 
423a361
> 
426,427d363
< class my_test_inst_da3 extends my_test;
<    `uvm_component_utils(my_test_inst_da3)
429,438d364
<     function new(string name="",uvm_component parent);
<         super.new(name, parent);
<     endfunction
<      
<     virtual function void build_phase(uvm_phase phase);
<         super.build_phase(phase);
< 	set_inst_override_by_type("m_env.m_agent.m_seqr.*",
< 			           my_transaction::get_type(),
< 			           my_transaction_da3::get_type());
<     endfunction
440,444c366,369
<     virtual function void report_phase(uvm_phase phase);
<         super.report_phase(phase);
< 	factory.print();
<     endfunction
< endclass
---
> 
> 
> 
> 
